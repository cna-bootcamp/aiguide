"""Event Storming Agent - 이벤트 스토밍 기법을 활용한 시퀀스 다이어그램 작성."""

from typing import Dict, Any
from .base_agent import BaseAgent


class EventStormingAgent(BaseAgent):
    """
    이벤트 스토밍 기법을 활용하여 시퀀스 다이어그램을 작성하는 에이전트
    User Story 작성 전에 실행되어 시스템의 이벤트 흐름을 파악합니다.
    """

    def __init__(self):
        super().__init__(
            name="이벤트 스토밍 에이전트",
            description="이벤트 스토밍 기법으로 시퀀스 다이어그램을 작성합니다."
        )

    def get_prompt_template(self, context: Dict[str, Any]) -> str:
        selected_solution = context.get("selected_solution", "")
        target_customer = context.get("target_customer", "")
        journey_map = context.get("journey_map", "")
        business_model = context.get("business_model", "")

        return f"""당신은 도메인 주도 설계(DDD) 및 이벤트 스토밍 전문가입니다.
선정된 솔루션을 기반으로 이벤트 스토밍 기법을 활용하여 시스템의 이벤트 흐름과 시퀀스 다이어그램을 작성해주세요.

선정된 솔루션:
{selected_solution if selected_solution else "솔루션 정보 없음"}

대상 고객:
{target_customer if target_customer else "고객 정보 없음"}

고객 여정:
{journey_map if journey_map else "여정 정보 없음"}

비즈니스 모델:
{business_model if business_model else "비즈니스 모델 없음"}

다음 형식으로 이벤트 스토밍 결과와 시퀀스 다이어그램을 작성해주세요:

---

# 이벤트 스토밍 결과서

## 1. 개요

### 목적
[이벤트 스토밍의 목적과 범위]

### 참여자 역할
- **도메인 전문가**: [역할 설명]
- **개발자**: [역할 설명]
- **UX 디자이너**: [역할 설명]
- **비즈니스 분석가**: [역할 설명]

### 진행 방식
- **방법론**: Event Storming (Alberto Brandolini)
- **단계**: Big Picture Event Storming → Process Modeling → Software Design

---

## 2. 도메인 이벤트 식별 (Domain Events)

> 도메인 이벤트는 비즈니스에서 발생하는 중요한 사건들입니다. 과거형으로 표현됩니다.

### 핵심 비즈니스 플로우별 이벤트

#### 플로우 1: [플로우명 - 예: 사용자 가입 및 온보딩]

| 순서 | 이벤트명 | 설명 | 트리거 |
|-----|---------|------|--------|
| 1 | [이벤트명] 발생됨 | [설명] | [무엇이 이 이벤트를 발생시키는가] |
| 2 | [이벤트명] 완료됨 | [설명] | [트리거] |
| 3 | [이벤트명] 등록됨 | [설명] | [트리거] |

#### 플로우 2: [플로우명 - 예: 서비스 이용]
[동일한 형식으로 5-10개의 이벤트 나열]

#### 플로우 3: [플로우명 - 예: 결제 및 구독 관리]
[동일한 형식으로 5-10개의 이벤트 나열]

#### 플로우 4: [플로우명 - 예: 고객 지원]
[동일한 형식으로 5-10개의 이벤트 나열]

---

## 3. 커맨드 (Commands)

> 커맨드는 이벤트를 발생시키는 사용자 또는 시스템의 행동입니다.

| 커맨드 | 설명 | 발생시키는 이벤트 | 실행 주체 |
|-------|------|------------------|----------|
| [커맨드명] | [설명] | [이벤트] | [사용자/시스템] |
| [20-30개의 주요 커맨드 나열] |

---

## 4. 애그리게이트 (Aggregates)

> 애그리게이트는 관련된 도메인 객체들의 묶음입니다.

### Aggregate 1: [애그리게이트명]
- **설명**: [애그리게이트 설명]
- **주요 속성**:
  - [속성 1]: [타입] - [설명]
  - [속성 2]: [타입] - [설명]
- **주요 메서드/행동**:
  - [메서드 1]: [설명]
  - [메서드 2]: [설명]
- **관련 이벤트**:
  - [이벤트 1]
  - [이벤트 2]

### Aggregate 2: [애그리게이트명]
[동일한 형식으로 5-10개의 애그리게이트 정의]

---

## 5. 액터 (Actors)

> 시스템과 상호작용하는 주체들입니다.

| 액터명 | 역할 | 주요 커맨드 | 관련 이벤트 |
|-------|------|-----------|------------|
| [액터명] | [역할 설명] | [커맨드 목록] | [이벤트 목록] |
| [5-10개의 액터 정의] |

---

## 6. 정책 (Policies)

> 정책은 이벤트 발생 시 자동으로 실행되는 비즈니스 규칙입니다.

| 정책명 | 트리거 이벤트 | 실행 조건 | 실행 커맨드 |
|-------|-------------|----------|-----------|
| [정책명] | [이벤트] | [조건] | [커맨드] |
| [10-15개의 정책 정의] |

---

## 7. 읽기 모델 (Read Models)

> 사용자에게 정보를 표시하기 위한 뷰/쿼리 모델입니다.

| 읽기 모델명 | 목적 | 포함 데이터 | 업데이트 이벤트 |
|-----------|------|-----------|---------------|
| [모델명] | [목적] | [데이터 항목] | [이벤트] |
| [10-15개의 읽기 모델 정의] |

---

## 8. 외부 시스템 (External Systems)

> 통합이 필요한 외부 시스템들입니다.

| 시스템명 | 목적 | 통합 방식 | 관련 이벤트 |
|---------|------|----------|------------|
| [시스템명] | [목적] | [API/메시징 등] | [이벤트] |
| [필요한 외부 시스템 나열] |

---

## 9. 타임라인 (Timeline)

> 시간 순서에 따른 이벤트 흐름을 시각화합니다.

### 핵심 사용자 시나리오 1: [시나리오명]

```
시작
  ↓
[사용자] → [커맨드: 회원가입 요청]
  ↓
[이벤트: 회원가입 요청됨]
  ↓
[정책: 이메일 검증 필요] → [커맨드: 인증메일 발송]
  ↓
[이벤트: 인증메일 발송됨]
  ↓
[사용자] → [커맨드: 이메일 인증 확인]
  ↓
[이벤트: 이메일 인증 완료됨]
  ↓
[정책: 프로필 설정 안내] → [커맨드: 온보딩 시작]
  ↓
[이벤트: 온보딩 시작됨]
  ↓
종료
```

### 핵심 사용자 시나리오 2: [시나리오명]
[동일한 형식으로 3-5개의 핵심 시나리오 타임라인 작성]

---

## 10. 시퀀스 다이어그램

> Mermaid 다이어그램 형식으로 주요 플로우의 시퀀스를 표현합니다.

### 시퀀스 1: [플로우명 - 예: 사용자 가입]

```mermaid
sequenceDiagram
    actor User as 사용자
    participant UI as UI/Frontend
    participant API as API Gateway
    participant Auth as 인증 서비스
    participant DB as 데이터베이스
    participant Email as 이메일 서비스

    User->>UI: 회원가입 요청
    UI->>API: POST /auth/register
    API->>Auth: 회원가입 처리
    Auth->>DB: 사용자 정보 저장
    DB-->>Auth: 저장 완료
    Auth->>Email: 인증 이메일 발송
    Email-->>User: 인증 메일 수신
    Auth-->>API: 가입 성공 응답
    API-->>UI: 201 Created
    UI-->>User: 가입 완료 메시지

    User->>Email: 인증 링크 클릭
    Email->>API: GET /auth/verify
    API->>Auth: 이메일 인증 확인
    Auth->>DB: 인증 상태 업데이트
    DB-->>Auth: 업데이트 완료
    Auth-->>API: 인증 성공
    API-->>UI: 인증 완료 페이지
    UI-->>User: 로그인 가능 안내
```

### 시퀀스 2: [플로우명 - 예: 서비스 이용]

```mermaid
sequenceDiagram
    [5-10개의 주요 플로우에 대한 상세한 시퀀스 다이어그램 작성]
```

### 시퀀스 3: [플로우명 - 예: 결제]
[동일한 형식]

### 시퀀스 4: [플로우명 - 예: 고객 지원]
[동일한 형식]

---

## 11. 바운디드 컨텍스트 (Bounded Contexts)

> 도메인을 논리적으로 구분한 경계입니다.

### 컨텍스트 1: [컨텍스트명 - 예: 사용자 관리]
- **책임**: [컨텍스트의 책임 범위]
- **포함 애그리게이트**: [애그리게이트 목록]
- **주요 이벤트**: [이벤트 목록]
- **외부 의존성**: [다른 컨텍스트와의 관계]

### 컨텍스트 2: [컨텍스트명 - 예: 결제 및 구독]
[동일한 형식으로 5-8개의 컨텍스트 정의]

---

## 12. 컨텍스트 매핑 (Context Mapping)

> 바운디드 컨텍스트 간의 관계와 통합 방식입니다.

```
[컨텍스트 A] --[관계 타입]--> [컨텍스트 B]

예:
사용자 관리 --[고객-공급자]--> 결제 서비스
결제 서비스 --[공유 커널]--> 구독 관리
구독 관리 --[발행-구독]--> 알림 서비스
```

| 업스트림 컨텍스트 | 다운스트림 컨텍스트 | 관계 타입 | 통합 방식 |
|-----------------|------------------|---------|----------|
| [컨텍스트 A] | [컨텍스트 B] | [Customer-Supplier 등] | [REST API/이벤트 등] |
| [모든 컨텍스트 간 관계 정의] |

---

## 13. 핫스팟 및 이슈 (Hotspots & Issues)

> 이벤트 스토밍 중 발견된 문제점, 불확실성, 논의가 필요한 사항들입니다.

| 핫스팟 | 카테고리 | 설명 | 해결 방안 | 우선순위 |
|-------|---------|------|----------|---------|
| [이슈명] | [기술/비즈니스/UX] | [상세 설명] | [제안된 해결책] | [High/Medium/Low] |
| [10-15개의 핫스팟 식별] |

---

## 14. 데이터 흐름도

### 전체 시스템 데이터 흐름

```
[사용자]
   ↓ (입력 데이터)
[프론트엔드]
   ↓ (API 요청)
[API Gateway]
   ↓
[마이크로서비스들]
   ├─ [서비스 A] ↔ [DB A]
   ├─ [서비스 B] ↔ [DB B]
   └─ [서비스 C] ↔ [DB C]
   ↓
[이벤트 버스/메시지 큐]
   ↓
[외부 시스템 통합]
```

---

## 15. User Story 작성을 위한 권장사항

### Epic과 User Story 도출
각 바운디드 컨텍스트와 애그리게이트를 기반으로 다음과 같이 Epic을 구성하세요:

#### Epic 1: [컨텍스트명 기반 Epic]
**도출된 User Stories**:
- Story 1.1: [이벤트 기반 스토리] - "[커맨드]를 수행할 수 있다"
- Story 1.2: [이벤트 기반 스토리] - "[이벤트 발생 시] ~한 알림을 받는다"
- [각 Epic별 5-10개의 스토리 아이디어 제시]

### 주요 사용자 플로우
1. **[플로우 1]**: [시작] → [이벤트들] → [종료]
2. **[플로우 2]**: [시작] → [이벤트들] → [종료]
3. **[플로우 3]**: [시작] → [이벤트들] → [종료]

### 기술적 요구사항
- **이벤트 소싱**: [필요 여부 및 적용 범위]
- **CQRS**: [필요 여부 및 적용 범위]
- **비동기 처리**: [필요한 부분]
- **트랜잭션 경계**: [중요한 트랜잭션 범위]

### 우선순위
1. **P0 (Must Have)**: [핵심 이벤트 및 플로우]
2. **P1 (Should Have)**: [중요 이벤트 및 플로우]
3. **P2 (Could Have)**: [부가 기능]

---

## 16. 종합 요약

### 주요 도메인 이벤트 수
- 총 이벤트: [N]개
- 커맨드: [N]개
- 애그리게이트: [N]개
- 바운디드 컨텍스트: [N]개

### 핵심 비즈니스 플로우
1. [플로우 1]: [설명]
2. [플로우 2]: [설명]
3. [플로우 3]: [설명]

### 기술 아키텍처 권장사항
- [권장사항 1]
- [권장사항 2]
- [권장사항 3]

---

**중요**:
- 모든 이벤트는 과거형으로 표현하세요 (예: "주문됨", "결제완료됨")
- 커맨드는 명령형으로 표현하세요 (예: "주문하기", "결제하기")
- 시퀀스 다이어그램은 실제 구현 가능한 수준으로 상세하게 작성하세요
- User Story Agent가 직접 활용할 수 있도록 구체적으로 작성하세요
- 최소 5개 이상의 핵심 플로우에 대한 시퀀스 다이어그램을 제공하세요
"""

    async def execute(self, context: Dict[str, Any]) -> Dict[str, Any]:
        """이벤트 스토밍 및 시퀀스 다이어그램 작성 실행"""
        try:
            if not self.validate_context(context, ["selected_solution"]):
                return self.format_error("Missing required context")

            if not await self.pre_execute(context):
                return self.format_error("Pre-execution validation failed")

            prompt = self.get_prompt_template(context)
            response = await self.call_claude(prompt, max_tokens=8000)

            result = self.format_output(
                content=response,
                metadata={
                    "methodology": "Event Storming",
                    "includes_sequence_diagrams": True,
                    "purpose": "user_story_preparation",
                    "output_format": "mermaid"
                }
            )

            return await self.post_execute(result)

        except Exception as e:
            return self.format_error(f"Error in Event Storming agent: {str(e)}")
